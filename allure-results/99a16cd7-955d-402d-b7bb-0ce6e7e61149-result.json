{"name": "test_get_all_ingredients", "status": "broken", "statusDetails": {"message": "gql.transport.exceptions.TransportConnectionFailed: HTTPConnectionPool(host='127.0.0.1', port=12334): Max retries exceeded with url: http://localhost:8080/graphql (Caused by ResponseError('too many 502 error responses'))", "trace": "urllib3.exceptions.ResponseError: too many 502 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x0000017188CA9190>, request = <PreparedRequest [POST]>, stream = False\ntimeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None\nproxies = OrderedDict({'http': 'http://127.0.0.1:12334', 'https': 'http://127.0.0.1:12334', 'ftp': 'http://127.0.0.1:12334'})\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\nvenv\\Lib\\site-packages\\requests\\adapters.py:644: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\nvenv\\Lib\\site-packages\\urllib3\\connectionpool.py:871: in urlopen\n    return self.urlopen(\nvenv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\nvenv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = 'http://localhost:8080/graphql'\nresponse = <urllib3.response.HTTPResponse object at 0x0000017188D3C850>, error = None\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x0000017188D0FF50>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=12334): Max retries exceeded with url: http://localhost:8080/graphql (Caused by ResponseError('too many 502 error responses'))\n\nvenv\\Lib\\site-packages\\urllib3\\util\\retry.py:535: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <gql.transport.requests.RequestsHTTPTransport object at 0x0000017188C92EA0>, request = <gql.graphql_request.GraphQLRequest object at 0x0000017187639D30>\ntimeout = None, extra_args = None, upload_files = False\n\n    def execute(\n        self,\n        request: GraphQLRequest,\n        timeout: Optional[int] = None,\n        extra_args: Optional[Dict[str, Any]] = None,\n        upload_files: bool = False,\n    ) -> ExecutionResult:\n        \"\"\"Execute GraphQL query.\n    \n        Execute the provided request against the configured remote server. This\n        uses the requests library to perform a HTTP POST request to the remote server.\n    \n        :param request: GraphQL request as a\n                        :class:`GraphQLRequest <gql.GraphQLRequest>` object.\n        :param timeout: Specifies a default timeout for requests (Default: None).\n        :param extra_args: additional arguments to send to the requests post method\n        :param upload_files: Set to True if you want to put files in the variable values\n        :return: The result of execution.\n            `data` is the result of executing the query, `errors` is null\n            if no errors occurred, and is a non-empty array if an error occurred.\n        \"\"\"\n    \n        if not self.session:\n            raise TransportClosed(\"Transport is not connected\")\n    \n        post_args = self._prepare_request(\n            request,\n            timeout=timeout,\n            extra_args=extra_args,\n            upload_files=upload_files,\n        )\n    \n        # Using the created session to perform requests\n        try:\n>           response = self.session.request(self.method, self.url, **post_args)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nvenv\\Lib\\site-packages\\gql\\transport\\requests.py:292: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x0000017188CA9190>, request = <PreparedRequest [POST]>, stream = False\ntimeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None\nproxies = OrderedDict({'http': 'http://127.0.0.1:12334', 'https': 'http://127.0.0.1:12334', 'ftp': 'http://127.0.0.1:12334'})\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPConnectionPool(host='127.0.0.1', port=12334): Max retries exceeded with url: http://localhost:8080/graphql (Caused by ResponseError('too many 502 error responses'))\n\nvenv\\Lib\\site-packages\\requests\\adapters.py:668: RetryError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_graphql.TestIngredientsGQL object at 0x0000017188C6EA80>\ningredients_gql_service = <tests.graphql.service.ingredients_service.IngredientsGQLService object at 0x0000017188CA8CE0>\n\n    @allure.story(\"–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤\")\n    def test_get_all_ingredients(self, ingredients_gql_service: IngredientsGQLService):\n        \"\"\"–¢–µ—Å—Ç –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤ —á–µ—Ä–µ–∑ GraphQL\"\"\"\n    \n        # –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å\n>       ingredients = ingredients_gql_service.get_all()\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\graphql\\test_suits\\test_graphql.py:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests\\graphql\\service\\ingredients_service.py:12: in get_all\n    return self.client.execute(\ntests\\graphql\\core\\graphql_client.py:86: in execute\n    result = self.client.execute(query, variable_values=variables or {})\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\gql\\client.py:497: in execute\n    return self.execute_sync(\nvenv\\Lib\\site-packages\\gql\\client.py:247: in execute_sync\n    with self as session:\nvenv\\Lib\\site-packages\\gql\\client.py:853: in __enter__\n    return self.connect_sync()\n           ^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\gql\\client.py:832: in connect_sync\n    self.session.fetch_schema()\nvenv\\Lib\\site-packages\\gql\\client.py:1263: in fetch_schema\n    execution_result = self.transport.execute(GraphQLRequest(introspection_query))\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gql.transport.requests.RequestsHTTPTransport object at 0x0000017188C92EA0>, request = <gql.graphql_request.GraphQLRequest object at 0x0000017187639D30>\ntimeout = None, extra_args = None, upload_files = False\n\n    def execute(\n        self,\n        request: GraphQLRequest,\n        timeout: Optional[int] = None,\n        extra_args: Optional[Dict[str, Any]] = None,\n        upload_files: bool = False,\n    ) -> ExecutionResult:\n        \"\"\"Execute GraphQL query.\n    \n        Execute the provided request against the configured remote server. This\n        uses the requests library to perform a HTTP POST request to the remote server.\n    \n        :param request: GraphQL request as a\n                        :class:`GraphQLRequest <gql.GraphQLRequest>` object.\n        :param timeout: Specifies a default timeout for requests (Default: None).\n        :param extra_args: additional arguments to send to the requests post method\n        :param upload_files: Set to True if you want to put files in the variable values\n        :return: The result of execution.\n            `data` is the result of executing the query, `errors` is null\n            if no errors occurred, and is a non-empty array if an error occurred.\n        \"\"\"\n    \n        if not self.session:\n            raise TransportClosed(\"Transport is not connected\")\n    \n        post_args = self._prepare_request(\n            request,\n            timeout=timeout,\n            extra_args=extra_args,\n            upload_files=upload_files,\n        )\n    \n        # Using the created session to perform requests\n        try:\n            response = self.session.request(self.method, self.url, **post_args)\n        except Exception as e:\n>           raise TransportConnectionFailed(str(e)) from e\nE           gql.transport.exceptions.TransportConnectionFailed: HTTPConnectionPool(host='127.0.0.1', port=12334): Max retries exceeded with url: http://localhost:8080/graphql (Caused by ResponseError('too many 502 error responses'))\n\nvenv\\Lib\\site-packages\\gql\\transport\\requests.py:294: TransportConnectionFailed"}, "description": "–¢–µ—Å—Ç –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤ —á–µ—Ä–µ–∑ GraphQL", "steps": [{"name": "GQL: –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤", "status": "broken", "statusDetails": {"message": "gql.transport.exceptions.TransportConnectionFailed: HTTPConnectionPool(host='127.0.0.1', port=12334): Max retries exceeded with url: http://localhost:8080/graphql (Caused by ResponseError('too many 502 error responses'))\n", "trace": "  File \"D:\\Coffeehouse-project\\tests\\graphql\\core\\graphql_client.py\", line 86, in execute\n    result = self.client.execute(query, variable_values=variables or {})\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Coffeehouse-project\\venv\\Lib\\site-packages\\gql\\client.py\", line 497, in execute\n    return self.execute_sync(\n           ^^^^^^^^^^^^^^^^^^\n  File \"D:\\Coffeehouse-project\\venv\\Lib\\site-packages\\gql\\client.py\", line 247, in execute_sync\n    with self as session:\n  File \"D:\\Coffeehouse-project\\venv\\Lib\\site-packages\\gql\\client.py\", line 853, in __enter__\n    return self.connect_sync()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Coffeehouse-project\\venv\\Lib\\site-packages\\gql\\client.py\", line 832, in connect_sync\n    self.session.fetch_schema()\n  File \"D:\\Coffeehouse-project\\venv\\Lib\\site-packages\\gql\\client.py\", line 1263, in fetch_schema\n    execution_result = self.transport.execute(GraphQLRequest(introspection_query))\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Coffeehouse-project\\venv\\Lib\\site-packages\\gql\\transport\\requests.py\", line 294, in execute\n    raise TransportConnectionFailed(str(e)) from e\n"}, "attachments": [{"name": "üîç GraphQL Query", "source": "3e108a66-3ecb-46db-a175-6c29244c2326-attachment.txt", "type": "text/plain"}, {"name": "‚ùå GraphQL Execution Error", "source": "6a24035c-8b86-4256-a51a-649e9d10c88c-attachment.txt", "type": "text/plain"}], "start": 1768584242822, "stop": 1768584244061}], "attachments": [{"name": "log", "source": "0f0add2c-cdf6-4271-ab4c-99e10b4ae49f-attachment.txt", "type": "text/plain"}], "start": 1768584242822, "stop": 1768584244074, "uuid": "1782b50c-b1e3-4f76-8163-e19070668360", "historyId": "330258fc8465337b819da1aaf0afe7d9", "testCaseId": "330258fc8465337b819da1aaf0afe7d9", "fullName": "tests.graphql.test_suits.test_graphql.TestIngredientsGQL#test_get_all_ingredients", "labels": [{"name": "story", "value": "–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤"}, {"name": "feature", "value": "GraphQL API: –ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã"}, {"name": "tag", "value": "ingredients"}, {"name": "tag", "value": "graphql"}, {"name": "parentSuite", "value": "tests.graphql.test_suits"}, {"name": "suite", "value": "test_graphql"}, {"name": "subSuite", "value": "TestIngredientsGQL"}, {"name": "host", "value": "magicBook"}, {"name": "thread", "value": "21400-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.graphql.test_suits.test_graphql"}], "titlePath": ["tests", "graphql", "test_suits", "test_graphql.py", "TestIngredientsGQL"]}